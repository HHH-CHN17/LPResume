## 介绍一下你最熟悉的项目

​	好的面试官，其实我感觉在复盘之后这些项目我都挺熟悉，那我就挑一个我自认为流程比较完整的项目来说说吧。<br/>	这个项目是LockWiper客户端的功能设计，是对前面学的所有知识的一个总结，要求是根据设计图设计出相应界面，并且实现该界面的特定功能。<br/>	在做需求开发的时候，我认为得先从看懂项目源码开始做起，这样才知道新代码该添加的哪个位置，当然得益于我之前对Fixppo做的逻辑流程图，其实我对公司管理项目的逻辑已经有了一定的了解，大体的思路是从main.cpp开始，和main.cpp放在一起的还有stdafx.h和stdafx.cpp；stdafx.h里放着可能会经常用到的头文件以及宏定义，和stdafx.cpp搭配使用是为了在第一次编译的时候生成.pch与.obj中间文件，这样的话在后续编译过程中编译器可以直接引用这两个文件，加快编译效率<br/>	然后就是MainView和MainViewWidaget，在MainView里面会进行公共组件库的初始化，显示软件基本框架，样式，main.cpp里面也是类似的，除此之外MainView还需要对MainViewWidget进行管理，MainViewWidget里面是主要功能模块入口的展示；值得注意的是，MainView主要的管理内容是对MainViewWidget传上来的信号进行管理以及对MainViewWIdget进行初始化，比如点击了进入某个模块的按钮，返回主界面，等一些进入其他界面的信号以及在显示该功能模块前是否需要先检测手机的连接状态。在另一个项目Fixppo中，由于主界面和其他功能模块的切换是通过QStackWidget进行管理的，所以在Fixppo中的MainView中，还需要设置另一个槽函数专门调用这些模块对象的deletelater()，这样的话当这些模块的事件循环结束之后，可以自动释放对应的对象，节省内存空间，同时为了避免野指针，还需要在调用deletelater()后将对象置NULL，同时也方便我以后重新创建对象。那么在对比之下，在LockWiper中，界面的切换并不是直接通过stackwidget进行管理的，他对功能模块对象的释放好像是通过另一个公共的类进行释放，这样的做法很容易被程序员疏忽，从代码易读性上来说是不如Fixppo的<br/>	那么其实在理解完MainView和MainViewWidget之后，就能大概理解公司对项目的代码管理了。就是说我要显示一个新界面的时候，我并不是在原有界面上直接显示新界面，而是先显示他的管理界面（空界面），然后在管理界面中，再去显示相应的ui界面，管理界面对于我们而言就是专门用来处理ui界面的信号，数据以及初始化ui的状态。这样做的好处是把我们ui相关的代码和与外界交互的数据进行分开处理，这样其他程序员想与我们的界面进行交互的时候，只需要看管理界面的代码即可，不需要把所有的代码都阅读一遍，增加了程序的可读性，方便后期的调试工作。当然除开这些ui相关的界面类以外，项目中还有一些其他的工作类，这些类的主要功能是用于初始化一些公共的参数，比如我在不同模块中用到的枚举值，以及一些宏定义<br/>	在了解完公司中文件的基本构成后，就可以顺理成章地知道新界面代码应该添加的位置（此处说说界面大致模样和实现方法）<br/>	在创建完新的源文件之后，需要手动将源文件按照项目中其他源文件一样分类放好。而且不出意外的话，新文件的.h头文件在其他类中引用时会出现无法识别头文件的错误，得益于之前学习CMake的经验，其实可以很容易想到是因为子目录的CMakeLists中在include_directories()未指明新的.h文件的位置造成的，直接手动添加即可。同时在CMakeLists中，为了让其他程序员在打开该项目时在vs左侧可以显示对应的文件夹，还需要通过file()指令浏览我新建的所有.h，.cpp，.ui文件并设置变量，再通过source_group()将这些文件加入到我想显示的文件夹中。需要注意的是，在Qt5.6.3+vs2013的平台下，不支持在CMake管理的项目中直接添加Qt类的，而我当时的作法是直接复制了公司其他类的代码来对我新建代码进行初始化，其实这样的做法不是很好，因为我们写代码的要求是要尽可能降低和其他代码的耦合度的，我这么做了之后也确实碰到了很多很多的bug，我印象比较深的是有两个bug，第一个是我在给界面设置属性的时候发现有些函数使用后编译报错显示没有此函数，这个错误解决起来比较简单，是因为在继承时他的父类是QObject，而我调用的函数其实是在QWidget里实现的，这让我对继承关系有了一定的理解，而且我发现在这些ui界面类的构造函数申明中，父类对象指针的默认参数为Q_NULLPTR，通过查看宏定义发现他其实就是nullptr，但其实我也不知道为什么要用Q_NULLPTR来代替，可能是从代码的规范角度来说的吧，对于我们程序员来说，我觉得我们需要注意的是不论代码有没有提供默认参数，我们都需要知道在创建ui界面类的时候是一定要提供父对象的，因为qt只重写了拷贝构造函数，在这种情况下，编译器不会提供默认的拷贝构造函数和有参构造函数，不指定父对象的话肯定会报错。第二个错误是编译器无法正确识别我的自定义类，无法创建自定义类的对象，我一开始是以为是新加了类之后编译器没反应过来，于是我首先的做法是重新构建，重新扫描解决方案再重新生成，发现错误依然存在，于是我想起前几天有其他的同事也碰到过这个问题，他们导致这个错误的原因是因为在不同环境下频繁修改源文件导致的源文件损坏，显然和我这个错误是不同的类型，<font color=red>得益于</font>我在Fixppo中修bug的经验，于是我在我自己的Demo中对这个问题进行了复现，发现依然报错，经过研究代码逻辑，发现逻辑并没有问题，于是想到是不是因为头文件的问题导致编译器无法正常识别我的自定义类，于是想到之前在学习的时候接触到的和头文件相关的错误叫做头文件重复包含，或者说类的重复包含，即类A用到了类B，类B又用到了类A，这种你中有我，我中有你的状态导致编译器无法正常编译代码，这个错误在和导师交流之后通过类的前置声明解决，不过需要注意的是，在使用类的前置申明时，该类的变量必须定义成指针的形式，不然编译器无法确定该对象所需要的空间，当然我觉得这个问题应该也可以通过头文件保护宏来解决（progma_once ifndef/define/endif）两者好像没啥区别，不过从跨平台的角度来说，还是后者好一些。<br/>	在改了很多很多的bug之后，程序终于可以正常运行了，吸取到的教训是以后新增文件时一定要在自己的demo中创建好再复制到项目中，减少和项目的耦合性。<br/>	在写代码的时候，也遇到了两个比较有意思的问题，<font color=red>第一个问题</font>是在做多语言翻译的时候，发现tr()文本是使用QMap统一在一个类中管理起来的，主要思路是先创建了一个类，在类中初始化了一个枚举值，用于存放各个tr()原文的名称，还有一个QMap，他的first存放的是枚举值，second是QString，存放tr()文本，需要翻译的时候调用该类的静态公共方法并传入枚举值。这样的作法显然是很危险的，比如添加一段新的翻译文本时，我首先要修改枚举值（讲讲会遇到的问题），又要修改qmap，会对源码产生较大改动，其实像Fixppo那样直接写在各个类对应的函数里就挺好的，但如果说一定要统一管理的话，其实在我学了一点设计模式的皮毛之后，我觉得可以尝试用一用工厂方法模式，具体思路如下：先创建一个抽象翻译类，然后根据需求创建具体翻译类，在类中对枚举值和QMap进行初始化（其实不用QMap也可以，因为后面会用switch），并提供一个接口，接口中使用switch…case…用来根据传入的枚举值返回特定的翻译文本，使用时直接用动态多态就可以了，这样做的好处是把不同类的代码分隔开，保证添加新类时不会修改源码，坏处是代码量大。<font color=red>第二个问题</font>是代码与主分支合并之后……

